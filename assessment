#!/usr/bin/env python

import dataclasses as dc
import statistics as st
import typing as ty
import click as cl
import configparser as cp
import pprint as pp

SPRACHE_KEY = 'sprache'
INHALT_KEY = 'inhalt'
FORMATIERUNG_KEY = 'formatierung'
QUELLENANGABE_KEY = 'quellenangabe'
IMPLEMENTIERUNG_KEY = 'implementierung'
EVALUATION_KEY = 'evaluation'
GEWICHTE_KEY = 'gewichte'


@dc.dataclass
class GradeAverages:
    sprache: float
    inhalt: float
    formatierung: float
    quellenangabe: float
    implementierung: float
    evaluation: float


@dc.dataclass
class GradeSections:
    sprache: ty.Dict[str, int]
    inhalt: ty.Dict[str, int]
    formatierung: ty.Dict[str, int]
    quellenangabe: ty.Dict[str, int]
    implementierung: ty.Dict[str, int]
    evaluation: ty.Dict[str, int]


def print_weights(weights: ty.Mapping[str, int]) -> None:

    cl.echo(pp.pformat(weights))


def config_items_to_dict(config_items: ty.Iterable[ty.Tuple[str, str]]
                         ) -> ty.Dict[str, int]:

    return {k: int(v) for k, v in dict(config_items).items()}


def print_grades(averages: GradeAverages, overall: float,
                 overall_rounded: float) -> None:

    cl.echo(f'{"Sprache:":<28}{averages.sprache:>3.2f}')
    cl.echo(f'{"Inhalt:":<28}{averages.inhalt:>3.2f}')
    cl.echo(f'{"Methode – Formatierung:":<28}{averages.formatierung:>3.2f}')
    cl.echo(f'{"Methode – Quellenangabe:":<28}{averages.quellenangabe:>3.2f}')
    cl.echo(
        f'{"Methode – Implementierung:":<28}{averages.implementierung:>3.2f}')
    cl.echo(f'{"Methode – Evaluation:":<28}{averages.evaluation:>3.2f}')
    cl.echo(f'{"-"*32}')
    cl.echo(f'{"Durchschnitt:":<28}{overall:>3.2f}')
    cl.echo(f'{"Gesamtnote:":<28}{overall_rounded:>3.1f}')


def get_grade_sections(config: cp.ConfigParser) -> GradeSections:

    sprache = config_items_to_dict(config.items(SPRACHE_KEY))

    inhalt = config_items_to_dict(config.items(INHALT_KEY))

    formatierung = config_items_to_dict(config.items(FORMATIERUNG_KEY))

    quellenangabe = config_items_to_dict(config.items(QUELLENANGABE_KEY))

    implementierung = config_items_to_dict(config.items(IMPLEMENTIERUNG_KEY))

    evaluation = config_items_to_dict(config.items(EVALUATION_KEY))

    return GradeSections(sprache, inhalt, formatierung, quellenangabe,
                         implementierung, evaluation)


def calculate_averages(config: cp.ConfigParser) -> GradeAverages:

    grade_sections = get_grade_sections(config)

    sprache_avg = st.mean(grade_sections.sprache.values())
    inhalt_avg = st.mean(grade_sections.inhalt.values())
    formatierung_avg = st.mean(grade_sections.formatierung.values())
    quellenangabe_avg = st.mean(grade_sections.quellenangabe.values())
    implementierung_avg = st.mean(grade_sections.implementierung.values())
    evaluation_avg = st.mean(grade_sections.evaluation.values())

    return GradeAverages(sprache_avg, inhalt_avg, formatierung_avg,
                         quellenangabe_avg, implementierung_avg,
                         evaluation_avg)


def load_grades(grades_file: str) -> cp.ConfigParser:

    config = cp.ConfigParser()
    config.read(grades_file)

    return config


def weigh_averages(averages: GradeAverages,
                   gewichte: ty.Mapping[str, int]) -> GradeAverages:

    sprache_weighted = averages.sprache * gewichte[SPRACHE_KEY]
    inhalt_weighted = averages.inhalt * gewichte[INHALT_KEY]
    formatierung_weighted = averages.formatierung * gewichte[FORMATIERUNG_KEY]
    quellenangabe_weighted = averages.quellenangabe * gewichte[
        QUELLENANGABE_KEY]
    implementierung_weighted = averages.implementierung * gewichte[
        IMPLEMENTIERUNG_KEY]
    evaluation_weighted = averages.evaluation * gewichte[EVALUATION_KEY]

    return GradeAverages(sprache_weighted, inhalt_weighted,
                         formatierung_weighted, quellenangabe_weighted,
                         implementierung_weighted, evaluation_weighted)


def calculate_weighted_average(weighted_averages: GradeAverages,
                               gewichte: ty.Mapping[str, int]) -> float:

    overall = weighted_averages.sprache \
        + weighted_averages.inhalt \
        + weighted_averages.formatierung \
        + weighted_averages.quellenangabe \
        + weighted_averages.implementierung \
        + weighted_averages.evaluation
    overall /= sum(gewichte.values())

    return overall


def calculate_overall(averages: GradeAverages,
                      gewichte: ty.Mapping[str, int]) -> float:

    weighted_averages = weigh_averages(averages, gewichte)

    return calculate_weighted_average(weighted_averages, gewichte)


def split_decimal_number(decimal_number: float) -> ty.Tuple[int, float]:

    integer = int(decimal_number)
    decimals = decimal_number % 1

    return integer, decimals


def round_to_nearest_grade(decimals: float) -> float:

    if decimals > 0.15 and decimals <= 0.5:
        return 0.3
    elif decimals > 0.5 and decimals <= 0.85:
        return 0.7
    elif decimals > 0.85:
        return 1.0
    else:
        return 0.0


def round_overall(overall: float) -> float:

    integer, decimals = split_decimal_number(overall)

    return integer + round_to_nearest_grade(decimals)


@cl.command()
@cl.argument('grades', type=cl.Path(exists=True), required=True, nargs=1)
@cl.option('--weights',
           is_flag=True,
           help='Show the section\'s weights and exit.')
@cl.version_option('1.0.0')
@cl.pass_context
def main(ctx: cl.Context, grades: str, weights: bool) -> None:

    config = load_grades(grades)
    section_weights = config_items_to_dict(config.items(GEWICHTE_KEY))

    if weights:
        print_weights(section_weights)
        ctx.exit()

    averages = calculate_averages(config)
    overall = calculate_overall(averages, section_weights)
    overall_rounded = round_overall(overall)

    print_grades(averages, overall, overall_rounded)


if __name__ == '__main__':
    main()
