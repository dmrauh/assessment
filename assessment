#!/usr/bin/env python

from dataclasses import dataclass
from statistics import mean
from typing import Dict, Iterable, Mapping, Tuple
from click import Context
from configparser import ConfigParser
import click
import pprint
import configparser

SPRACHE_KEY = 'sprache'
INHALT_KEY = 'inhalt'
FORMATIERUNG_KEY = 'formatierung'
QUELLENANGABE_KEY = 'quellenangabe'
IMPLEMENTIERUNG_KEY = 'implementierung'
EVALUATION_KEY = 'evaluation'
GEWICHTE_KEY = 'gewichte'


@dataclass
class GradeAverages:
    sprache: float
    inhalt: float
    formatierung: float
    quellenangabe: float
    implementierung: float
    evaluation: float


@dataclass
class GradeSections:
    sprache: Dict[str, int]
    inhalt: Dict[str, int]
    formatierung: Dict[str, int]
    quellenangabe: Dict[str, int]
    implementierung: Dict[str, int]
    evaluation: Dict[str, int]


def print_weights(weights: Mapping[str, int]) -> None:

    click.echo(pprint.pformat(weights))


def config_items_to_dict(config_items: Iterable[Tuple[str, str]]
                         ) -> Dict[str, int]:

    return {k: int(v) for k, v in dict(config_items).items()}


def print_grades(averages: GradeAverages, overall: float,
                 overall_rounded: float) -> None:

    click.echo(f'{"Sprache:":<28}{averages.sprache:>3.2f}')
    click.echo(f'{"Inhalt:":<28}{averages.inhalt:>3.2f}')
    click.echo(f'{"Methode – Formatierung:":<28}{averages.formatierung:>3.2f}')
    click.echo(
        f'{"Methode – Quellenangabe:":<28}{averages.quellenangabe:>3.2f}')
    click.echo(
        f'{"Methode – Implementierung:":<28}{averages.implementierung:>3.2f}')
    click.echo(f'{"Methode – Evaluation:":<28}{averages.evaluation:>3.2f}')
    click.echo(f'{"-"*32}')
    click.echo(f'{"Durchschnitt:":<28}{overall:>3.2f}')
    click.echo(f'{"Gesamtnote:":<28}{overall_rounded:>3.1f}')


def get_grade_sections(config: ConfigParser) -> GradeSections:

    sprache = config_items_to_dict(config.items(SPRACHE_KEY))

    inhalt = config_items_to_dict(config.items(INHALT_KEY))

    formatierung = config_items_to_dict(config.items(FORMATIERUNG_KEY))

    quellenangabe = config_items_to_dict(config.items(QUELLENANGABE_KEY))

    implementierung = config_items_to_dict(config.items(IMPLEMENTIERUNG_KEY))

    evaluation = config_items_to_dict(config.items(EVALUATION_KEY))

    return GradeSections(sprache, inhalt, formatierung, quellenangabe,
                         implementierung, evaluation)


def calculate_averages(config: ConfigParser) -> GradeAverages:

    grade_sections = get_grade_sections(config)

    sprache_avg = mean(grade_sections.sprache.values())
    inhalt_avg = mean(grade_sections.inhalt.values())
    formatierung_avg = mean(grade_sections.formatierung.values())
    quellenangabe_avg = mean(grade_sections.quellenangabe.values())
    implementierung_avg = mean(grade_sections.implementierung.values())
    evaluation_avg = mean(grade_sections.evaluation.values())

    return GradeAverages(sprache_avg, inhalt_avg, formatierung_avg,
                         quellenangabe_avg, implementierung_avg,
                         evaluation_avg)


def load_grades(grades_file: str) -> ConfigParser:

    config = configparser.ConfigParser()
    config.read(grades_file)

    return config


def weigh_averages(averages: GradeAverages,
                   gewichte: Mapping[str, int]) -> GradeAverages:

    sprache_weighted = averages.sprache * gewichte[SPRACHE_KEY]
    inhalt_weighted = averages.inhalt * gewichte[INHALT_KEY]
    formatierung_weighted = averages.formatierung * gewichte[FORMATIERUNG_KEY]
    quellenangabe_weighted = averages.quellenangabe * gewichte[
        QUELLENANGABE_KEY]
    implementierung_weighted = averages.implementierung * gewichte[
        IMPLEMENTIERUNG_KEY]
    evaluation_weighted = averages.evaluation * gewichte[EVALUATION_KEY]

    return GradeAverages(sprache_weighted, inhalt_weighted,
                         formatierung_weighted, quellenangabe_weighted,
                         implementierung_weighted, evaluation_weighted)


def calculate_weighted_average(weighted_averages: GradeAverages,
                               gewichte: Mapping[str, int]) -> float:

    overall = weighted_averages.sprache \
        + weighted_averages.inhalt \
        + weighted_averages.formatierung \
        + weighted_averages.quellenangabe \
        + weighted_averages.implementierung \
        + weighted_averages.evaluation
    overall /= sum(gewichte.values())

    return overall


def calculate_overall(averages: GradeAverages,
                      gewichte: Mapping[str, int]) -> float:

    weighted_averages = weigh_averages(averages, gewichte)

    return calculate_weighted_average(weighted_averages, gewichte)


def split_decimal_number(decimal_number: float) -> Tuple[int, float]:

    integer = int(decimal_number)
    decimals = decimal_number % 1

    return integer, decimals


def round_to_nearest_grade(decimals: float) -> float:

    if decimals > 0.15 and decimals <= 0.5:
        return 0.3
    elif decimals > 0.5 and decimals <= 0.85:
        return 0.7
    elif decimals > 0.85:
        return 1.0
    else:
        return 0.0


def round_overall(overall: float) -> float:

    integer, decimals = split_decimal_number(overall)

    return integer + round_to_nearest_grade(decimals)


@click.command()
@click.argument('grades', type=click.Path(exists=True), required=True, nargs=1)
@click.option('--weights',
              is_flag=True,
              help='Show the section\'s weights and exit.')
@click.version_option('1.0.0')
@click.pass_context
def main(ctx: Context, grades: str, weights: bool) -> None:

    config = load_grades(grades)
    section_weights = config_items_to_dict(config.items(GEWICHTE_KEY))

    if weights:
        print_weights(section_weights)
        ctx.exit()

    averages = calculate_averages(config)
    overall = calculate_overall(averages, section_weights)
    overall_rounded = round_overall(overall)

    print_grades(averages, overall, overall_rounded)


if __name__ == '__main__':
    main()
